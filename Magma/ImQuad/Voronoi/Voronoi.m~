import "../../BasicDataImQuad.m": n,d,steinitz;
import "../../InitializeImQuad.m": K,w,tau,p1,p2,ZB,B,BasHermNorm,mmax,F,sqrtd,Injec;
import "../../QHullDirectory.m": qhulldirectory;
import "../Functions/Groups.m": matbas,matbas2,matbas3;

//Returnwert hiervon noch anpassen!!

intrinsic VoronoiAlgorithm() -> VData
 {ImQuad: Voronoi algorithm.}
 //Find a first perfect form

 Pini:=MatrixRing(K,n)!1;
 Pini[n][n]:=1/Norm(p2);
 Pinie:=TraceForm(Pini);
 Pinie2:=TraceForm(w*Pini);
 Lini:=LatticeWithGram(Pinie);
 Sini:=MinimalVectors(Pini);
 Rini:=PerfectionRank(Pini);

 count:=1;

 while Rini lt n^2 and count lt 100 do
  count:=count+1;
  dir:=FindPerpListMatrix(Sini);
  tsup:=1000;
  tinf:=0;
  t:=(tsup+tinf)/2;
  bool:=false;
  count2:=1;

  while not bool and count2 lt 100 do
   count2:=count2+1;
   M:=1;
   Pt:=Pini+t*dir;
   while M eq 1 do
    if IsPositiveDefinite(TraceForm(Pt)) then
     Lt:=LatticeWithGram(TraceForm(Pt));
     M:=HermitianMinimum(Pt);
     if M eq 1 then
      tinf:=t;
      t:=(tinf+tsup)/2;
      Pt:=Pini+t*dir;
     end if;
    else
     tsup:=t;
     t:=(tinf+tsup)/2;
     Pt:=Pini+t*dir;
    end if;
   end while;
   St:=MinimalVectors(Pt);

   tt:=Rationals()!
      Min([(IdealNorm(v)-K!((v*Pini*HermitianTranspose(v))[1,1]))/(K!((v*dir*HermitianTranspose(v))[1,1])) : v in St]);
   bool:=false;
   if tt lt t and tt gt 0 then
    Pc:=Pini+tt*dir;
    Pce:=TraceForm(Pc);
    Lc:=LatticeWithGram(Pce);
    M:=HermitianMinimum(Pc);
    if M eq 1 then
     bool:=true;
    else
     tsup:=tt;
     t:=(tinf+tsup)/2;
     Pt:=Pini+t*dir;
    end if;
   else
    tsup:=t;
    t:=(tsup+tinf)/2;
    Pt:=Pini+t*dir;
   end if;
  end while;

  Pini:=Pc;
  Pinie:=TraceForm(Pini);

  Lini:=LatticeWithGram(Pinie);
  Sini:=MinimalVectors(Pini);
  Rini:=PerfectionRank(Pini);
 end while;

 if Rini ne n^2 then
  error "In FirstPerfect: the form Rini is not perfect.";
 end if;

 //Enumerate perfect neighbours in order to obtain a set of representatives
 //of perfect Hermitian forms

 perfectlist:=[Pini];         //List of representatives of perfect forms
 vectlist:=[**];              //List of shortest vectors of perfect forms
 facelist:=[**];              //List of facets of V-domains of p. forms; given by shortest vectors
 faceneu:=[**];               // 1 at [i][j] if neighbor(facelist[i][j]) >= i
                              // 0 else
 facevectList:=[**];          //Perpendicular form to shortest vectors defining the respective facet
 Dim2facevectList:=[**];      //
 FaceFormList:=[**];          //List of forms defined by those shortest vectors, which define the respective facet
 AutList:=[**];               //List of Aut-Groups of the inverse FaceForms
 Dim2FormList:=[**];          //
 Dim2FaceList:=[**];          //
 Dim2AutList:=[**];           //

 numberoffaces:=[];           //List of number of faces of V-domains of p. forms
 E:={**};                     //multiset encoding the Voronoi graph of perfect forms
 Todo:=[Pini];                //List of perfect forms to be treated with Voronoi
 minvecss:=[MinimalVectors(Pini)];
 PerfectNeighbourList:=[**];  //List of perfect neighbours of all (mod GL) perfect forms

 CriticalValueList:=[**];     //List of critical rho values (from Voronoi's algorithm)
 FacetVectorList:=[**];       //List of facet vectors (from Voronoi's algorithm)

 FaceTrafoList:=[**];

 NeighbourList:=[**];         //List of numbers of standard representatives of neighbours

 while(#Todo gt 0) do
  P:=Todo[1];
  Pe:=TraceForm(P);
  L:=LatticeWithGram(Pe);
  m:=HermitianMinimum(P);
  Sk:=MinimalVectors(P);
  Sproj:=[ProjectionCoordinates(v) : v in Sk];
  Append(~vectlist,Sk);

  Exclude(~Todo,Todo[1]);

  if PerfectionRankList(Sk) ne n^2 then
   error "In enumerating perfect neighbours: perfection rank of potential neighbour is too small.";
  end if;

  G:=HermitianAutomorphismGroup(P);
  G:=ChangeRing(G,Rationals());
/*
  DonQhull:=Open("DonneePourQhull","w");
  Puts(DonQhull, IntegerToString(n^2) cat " RBOX c");
  Puts(DonQhull, IntegerToString(#Sproj+1) );
  Puts(DonQhull, &cat ["0 " : i in [1..n^2] ] );
  for st in [ &cat [RealToString(Injec(n)) cat " " : n in Eltseq(X)] : X in Sproj] do
   Puts(DonQhull,st);
  end for;
  delete DonQhull;

  //INSERT DIRECTORY OF QHULL HERE
  System(qhulldirectory cat " -Fv <DonneePourQhull >SommetsParFace");

  Faces:=[];
  SomFac:=Open("SommetsParFace","r");
  nbface := StringToInteger(Gets(SomFac));
  for i in [1..nbface] do
   Faces:=Append(Faces, Remove([StringToInteger(n) : n in Split(Gets(SomFac)," ")],1));
  end for;
  delete SomFac;
  Faces:=[ Exclude(F,0) : F in Faces | 0 in F];
  Faces:=[ {n : n in F} : F in Faces];
  print "Usual faces:"; print Faces;
*/
  Sprojtest:=[HermitianTranspose(v)*v : v in Sk];
  GeneratorsOfPolytope:=[[Rationals()!0 : i in [1..n^2]]];
  for X in Sprojtest do
   g:=[];
   for i in [1..n] do
    Append(~g,Rationals()!X[i][i]);
    for j in [i+1..n] do
     g cat:= Eltseq(X[i][j]);
    end for;
   end for;
   Append(~GeneratorsOfPolytope,g);
  end for;
  //return GeneratorsOfPolytope;
  print "Generators of Polytope constructed.";
  Poly:=Polytope(GeneratorsOfPolytope);
  print "Polytope constructed.";
  Faces:=FaceIndices(Poly,n^2-1);
  print "Faces calculated.";
  Faces:=[Exclude(x,1) : x in Faces | 1 in x];
  Faces:=[{a-1 : a in x} : x in Faces];
  //return Faces;

  Append(~numberoffaces,#Faces);
  Append(~facelist,Faces);
  FaceForms:=[];
  AutFF:=[];
  facevect:=[];
  for F in Faces do
   FF:=Parent(Pini) ! 0;
   for k in F do
    Fk:= HermitianTranspose(Sk[k])*Sk[k];
    FF := FF+ Fk;
   end for;
   gL:=FindPerpListList([Sk[k] : k in F]);
   if #gL eq 1 then
    Append(~facevect,gL);
   end if;
  end for;
  Append(~facevectList,facevect);

  count:=0;

  //print Faces;
 
  PerfectNeighbours:=[**];    //List of perfect neighbours of P being treated
  Neighbours:=[**];           //List of indices of standard representatives of perf. neighbours of P
  CriticalValues:=[**];       //List of critical rho-values of P
  fneu:=[];
  TrafoList:=[**];
  while(#Faces gt 0) do
   count:=count+1;
   F1:=FindPerpListMatrix1([Sk[n] : n in Faces[1]]);
   Append(~FacetVectorList,F1);  //[??]
   Exclude(~Faces,Faces[1]);
   sgn:=Sign(&+ [Rationals()!EvaluateVector(F1,x) : x in Sk]);
   F1:=sgn*F1;

   tsup:=10000;
   tinf:=0;
   t:=(tinf+tsup)/2;
   minimcont:=0;
   while minimcont ne 1 do
    coherent:=false;
    while not coherent do
     Pt:=P+t*F1;
     M:=1;
     while M eq 1 do
      if IsPositiveDefinite(TraceForm(Pt)) then
       M:=HermitianMinimum(Pt);
       if M eq 1 then
        tinf:=t;
        t:=(tinf+tsup)/2;
        Pt:=P+t*F1;
       end if;
      else
       tsup:=t;
       t:=(tinf+tsup)/2;
       Pt:=P+t*F1;
      end if;
     end while;
     St:=MinimalVectors(Pt);
     SFace:=[ s : s in Sk | EvaluateVector(F1,s) eq 0];
 
     Cond:=[ProjectionCoordinates(s) : s in SFace] cat [ProjectionCoordinates(s) : s in St];
     Uns:=Vector( #Cond , [ F!(IdealNorm(v)) : v in SFace ] cat [F!(IdealNorm(v)) : v in St] );
     Cond:=Transpose(Matrix(Cond));
 
     coherent:=IsConsistent(Cond,Uns);
     if not coherent then
      tsup:=t;
      t:=(tinf+tsup)/2;
      Pt:=P+t*F1;
     end if;
    end while;
    Pcont:=CoordinatesToMatrix(Solution(Cond,Uns));
    Pconte:=TraceForm(Pcont);
    Lcont:=LatticeWithGram(Pconte);
    //Scont:=ShortVectors(Lcont,hermitianmin(Pcont)/mmax,hermitianmin(Pcont)*mmax);
    Scontk:=MinimalVectors(Pcont);
 
    minimcont:=HermitianMinimum(Pcont);
 
    tsup:=t;
    t:=(tinf+tsup)/2;
    Pt:=P+t*F1;
   end while;
 
   Append(~PerfectNeighbours,Pcont);
 
   //Determine critical value rho:
   C:=Pcont-P;
   I:=0; J:=0;
   for i in [1..n] do
    for j in [1..n] do
     if C[i][j] ne 0 then
      I:=i; J:=j;
      break i;
     end if;
    end for;
   end for;
   Append(~CriticalValues , sgn*(C[I][J])/(F1[I][J]) );
 
 
   iso:=false;
   jjj := Position(perfectlist,P);
   for i in [1..#perfectlist] do
    bool,trans:=TestIsometry(Pcont,perfectlist[i]);
    if bool then
     iso:=true;
     Include(~E,<jjj,i>);
     if jjj  le i then Append(~fneu,1); else Append(~fneu,0); end if;
     Append(~Neighbours,i);
     break;
    end if;
   end for;
   if not iso then
    Append(~perfectlist,Pcont);
    Append(~minvecss,MinimalVectors(Pcont));
    Append(~fneu,1);
    Append(~Todo,Pcont);
    Append(~TrafoList,MatrixRing(Integers(),2*n)!1);
    Include(~E,<Position(perfectlist,P),Position(perfectlist,Pcont)>);
    Append(~Neighbours,#perfectlist);
   else
    Append(~TrafoList,trans);
   end if;
  end while;
  Append(~faceneu,fneu);
  Append(~PerfectNeighbourList,PerfectNeighbours);
  Append(~CriticalValueList,CriticalValues);
  Append(~FaceTrafoList,matbas(TrafoList));
  Append(~NeighbourList,Neighbours);
 end while;

 //Create a generating set of GL(L) as Z-matrices
 X:=[];
 for p in perfectlist do
  X:=X cat [MatrixRing(Integers(),2*n)!x : x in Generators(HermitianAutomorphismGroup(p))];
 end for;
 /*for L in PerfectNeighbourList do
  for A in L do
   for p in perfectlist do
    a,b:=TestIsometry(A,p);
    if a then
     Append(~X,MatrixRing(Integers(),2*n)!b);
    end if;
   end for;
  end for;
 end for;
 //"Clean up" X:
 //while MatrixRing(Integers(),2*n)!1 in X do
 // Remove(~X,Position(X,MatrixRing(Integers(),2*n)!1));
 //end while;*/
 for a in FaceTrafoList do
  X cat:= matbas2(a);
 end for;
 ZGENS:=X;             //Z-generating system
 OKGENS:=matbas(X);    //OK-generating system
 OKGENS:=SetToSequence(SequenceToSet(OKGENS));
 OKGENS:=[x: x in OKGENS| x ne Parent(x)!1];

 V:=New(VData);
 //Context,PerfectList,FacesList,FaceTrafoList,ZGens,OKGens,CriticalValueList,NeighbourList,Edges,Barycenters,Stabilizers;
 V`Context:="ImQuad";
 V`n:=n;
 V`d:=d;
 V`PerfectList:=perfectlist;
 V`FacesList:=facelist;
 V`ZGens:=ZGENS;
 V`OKGens:=OKGENS;
 V`CriticalValueList:=CriticalValueList;
 V`FaceTrafoList:=FaceTrafoList;
 V`NeighbourList:=NeighbourList;
 V`PerfectNeighbourList:=PerfectNeighbourList;
 
 return V;
end intrinsic;
