import "../../BasicDataImQuad.m": n,d,steinitz;
import "../../InitializeImQuad.m": K,w,tau,p1,p2,ZB,B,BasHermNorm,mmax; 

intrinsic TraceForm(A::Mtrx) -> Mtrx
 {for a matrix A returns the trace form of A}
 res:=MatrixRing(Rationals(),2*n) ! 0;
 for i in [1..2*n] do
  for j in [1..2*n] do
   res[i][j]:=Rationals()!Trace(K!(B[i]*A*HermitianTranspose(B[j]))[1][1]);
  end for;
 end for;
 res:=(1/2)*res;
 return res;
end intrinsic;

intrinsic EvaluateVector(A::Mtrx,x::Mtrx) -> FldQuad
 {evaluates x at A}
 x:=KMatrixSpace(K,1,n)!x;
 z:=K!0; N:=K!0; I:=ideal<Integers(K)|0>;
 z:=K!((x*A*HermitianTranspose(x))[1][1]);
 for i in [1..n-1] do
  I:=I+x[1][i]*p1;
 end for;
 I:=I+x[1][n]*(p1/p2);
 N:=Norm(I);
 return z/N;
end intrinsic;

intrinsic ShortenVectors(A::AlgMatElt,m::FldQuadElt,S::SeqEnum) -> SeqEnum
 {for a list of short vectors in a Z-lattice of dimension 2*n by 2*n 
  return the corresponding list of shortest vectors of A with minimum m in dimension n}
 res:=[];
 for i in [1..#S] do
  x:=Vector(S[i][1]);
  xk:=KMatrixSpace(K,1,n)!0;
  for j in [1..2*n] do
   xk:=xk+x[j]*B[j];
  end for;
  if EvaluateVector(A,xk) eq m then
   Append(~res,xk);
  end if;
 end for;
 return res;
end intrinsic;

intrinsic ShortenVector(x::Mtrx) -> Mtrx
 {shortens a 2*n-vector into an n-vector}
 res:=KMatrixSpace(K,1,n)!0;
 for j in [1..2*n] do
  res:=res+x[j]*B[j];
 end for;
 return res;
end intrinsic;

intrinsic IdealNorm(x::Mtrx) -> FldRatElt
 {return the norm of the ideal corresponding to the vector x} 
 N:=0;
 I:=ideal<Integers(K) | 0>;
 for i in [1..n-1] do
  I:=I+x[1][i]*(p1);
 end for;
 I:=I+x[1][n]*(p1/p2);
 N:=Norm(I);
 return N;
end intrinsic;

intrinsic HermitianMinimum(A::Mtrx) -> FldRatElt
 {returns the minimum of A on the lattice L}
 L:=LatticeWithGram(TraceForm(A));
 minL:=Minimum(L);
 S:=ShortVectors(L,minL/mmax,minL*mmax);
 m:=Min([EvaluateVector(A,ShortenVector(s[1])) : s in S]);
 return m;
end intrinsic;

intrinsic PerfectionRankList(M::SeqEnum) -> RngIntElt
 {returns the perfection rank of the set of vectors M}
 VV:=[];
 for m in M do s:=Matrix(m[1]);
  v:=HermitianTranspose(s)*Matrix(s);
  Append(~VV, ElementToSequence(v));
 end for;
 return Rank(Matrix(VV)) ;
end intrinsic;

intrinsic PerfectionRank(M::Mtrx) -> RngIntElt
 {returns the perfection rank of the matrix M}
 L:=LatticeWithGram(TraceForm(M));
 m:=HermitianMinimum(M);
 S:=ShortVectors(L,m/mmax,m*mmax);
 Sk:=ShortenVectors(M,m,S);
 return PerfectionRankList(Sk);
end intrinsic;

intrinsic PerfectionCorank(M::Mtrx) -> RngIntElt
 {}
 return n^2-PerfectionRank(M);
end intrinsic;

RemoveMultiples:=function(M);
 V:=VectorSpace(K,n);
 out:=[];
 Append(~out,M[1]);
 for m in M do;
 ismultiple:=false;
  for v in out do;
   if Vector(m) in sub<V|[Vector(v)]> then;
    ismultiple:=true;
   end if;
  end for;
  if not ismultiple then;
   Append(~out,m);
  end if;
 end for;
 return out;
end function;

intrinsic MinimalVectors(A::Mtrx) -> SeqEnum
 {returns a mutiple-free list of minimal vectors of A}
 L:=LatticeWithGram(TraceForm(A));
 m:=HermitianMinimum(A);
 S:=ShortVectors(L,m/mmax,m*mmax);
 Sk:=ShortenVectors(A,m,S);
 Sk:=RemoveMultiples(Sk);
 return Sk;
end intrinsic;

intrinsic TestIsometry(M::Mtrx[FldQuad],N::Mtrx[FldQuad]) -> BoolElt,Any
 {Tests A and B for isometry}
 Me:=TraceForm(M);
 Ne:=TraceForm(N);
 mul1:=Lcm([Denominator(x) : x in Eltseq(Me)]);
 mul2:=Lcm([Denominator(x) : x in Eltseq(Ne)]);
 Me:=ChangeRing(mul1*mul2*Me,Integers());
 Ne:=ChangeRing(mul1*mul2*Ne,Integers());
 LM:=LatticeWithGram(Me);
 LN:=LatticeWithGram(Ne);

 Me2:=TraceForm(tau*M);
 Ne2:=TraceForm(tau*N);

 mul1:=Lcm([Denominator(x) : x in Eltseq(Me2)]);
 mul2:=Lcm([Denominator(x) : x in Eltseq(Ne2)]);
 Me2:=ChangeRing(mul1*Me2,Integers());
 Ne2:=ChangeRing(mul2*Ne2,Integers());

 a,b:=IsIsometric(LM,[Me2],LN,[Ne2]);

 if a then
  return a,b;
 else
  return false,"No isometry";
 end if;
end intrinsic;


