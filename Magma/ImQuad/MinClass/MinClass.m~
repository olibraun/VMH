import "../../BasicDataImQuad.m": n,d,steinitz;
import "../../InitializeImQuad.m": K,w,tau,p1,p2,ZB,B,BasHermNorm,mmax,F,sqrtd,Injec;
import "../../QHullDirectory.m": qhulldirectory;
import "../Functions/Groups.m": matbas,matbas2,matbas3;

limit:=3;

intrinsic MinimalClasses(perfectlist::SeqEnum,facelist::Any,facevectList::Any,CriticalValueList::Any) -> SeqEnum
 {.....}
/*
autlist:=[#aut(p) : p in perfectlist];
//print autlist;
//Write lists in order to identify automorphism groups with GAP
if Maximum(autlist) lt 2000 then
 L1:=Open("Liste1","w");
 Puts(L1, "Liste1:=[");
 for i in [1..#perfectlist] do
  if i ne #perfectlist then
   Puts(L1, IntegerToString(IdentifyGroup(aut(perfectlist[i]))[1]) cat " , ");
  else
   Puts(L1, IntegerToString(IdentifyGroup(aut(perfectlist[i]))[1]));
  end if;
 end for;
 Puts(L1, " ];");
 delete L1;

 L2:=Open("Liste2","w");
 Puts(L2, "Liste2:=[");
 for i in [1..#perfectlist] do
  if i ne #perfectlist then
   Puts(L2, IntegerToString(IdentifyGroup(aut(perfectlist[i]))[2]) cat " , ");
  else
   Puts(L2, IntegerToString(IdentifyGroup(aut(perfectlist[i]))[2]));
  end if;
 end for;
 Puts(L2, " ];");
 delete L2;

end if;
*/
FaceTupleList:=[**];                           //This will contain the tuples of faces of codim>1
Representatives:=[* perfectlist *];            //Representatives of all minimal classes
FaceTupleListOfRepresentatives:=[* [] *];      //We need this to check the dimension of the intersection

print "Starting the computation of minimal classes. Please be patient.";

//n=2

if n eq 2 then

 //Generate the tuples
 for i in [1..#perfectlist] do
  FaceTuples:=[**];
  S:=MinimalVectors(perfectlist[i]);
  for j in [1..#facelist[i]] do
   for k in [j+1..#facelist[i]] do
    Intersection:=facelist[i][j] meet facelist[i][k];
    if #Intersection gt 1 then
     if #FindPerpListList([S[l] : l in Intersection]) eq 2 then
      Append(~FaceTuples,[j,k]);
      if k gt #facelist[i] then print "Error."; end if;
     end if;
    end if;
   end for;
  end for;
  Append(~FaceTupleList,FaceTuples);
 end for;
 FaceTupleList:= [* FaceTupleList *];       //This is a bit clumsy; now FTL[1] is the data for codim 2

 //Compute corank 1 classes:

 TempList:=[**];
 for i in [1..#perfectlist] do
  for j in [1..#CriticalValueList[i]] do
   Append(~TempList , perfectlist[i]+(CriticalValueList[i][j]/2)*facevectList[i][j][1] );
  end for;
 end for;

 MinClassReps:=[TempList[1]];
 for x in TempList do
  isi:=false;
  for y in MinClassReps do
   if AreEquivalentMinimalClasses(x,y) then
    isi:=true;
   end if;
  end for;
  if not isi then
   Append(~MinClassReps,x);
  end if;
 end for;

 Append(~Representatives,MinClassReps);
 print "Corank 1 done.";

 //Compute classes of corank >= 2

 codim:=2;

 while n^2-codim ge n do
  TempList:=[**];
  for i in [1..#perfectlist] do
   for j in [1..#FaceTupleList[codim-1][i]] do
    T:=MatrixRing(K,n)!perfectlist[i];
    for k in FaceTupleList[codim-1][i][j] do
     T:=T+(CriticalValueList[i][k]/(2*codim))*facevectList[i][k][1];
    end for;
    Append(~TempList,T);
   end for;
  end for;

  MinClassReps:=[TempList[1]];
  for x in TempList do
   isi:=false;
   for y in MinClassReps do
    if AreEquivalentMinimalClasses(x,y) then
     isi:=true;
    end if;
   end for;
   if not isi then
    Append(~MinClassReps,x);
   end if;
  end for;

  Append(~Representatives,MinClassReps);
  codim:=codim+1;
 end while;
end if;


//n=3

if n eq 3 then
 //Generate the tuples
 print "n=3";
 print "Starting to assemble the tuples";

 for i in [1..#perfectlist] do
  FaceTuples:=[**];
  S:=MinimalVectors(perfectlist[i]);
  for j in [1..#facelist[i]] do
   for k in [j+1..#facelist[i]] do
    Intersection:=facelist[i][j] meet facelist[i][k];
    if #Intersection gt 1 then
     if #FindPerpListList([S[l] : l in Intersection]) eq 2 then
      Append(~FaceTuples,[j,k]);
      if k gt #facelist[i] then print "Error."; end if;
     end if;
    end if;
   end for;
  end for;
  Append(~FaceTupleList,FaceTuples);
 end for;
 FaceTupleList:= [* FaceTupleList *];       //This is a bit clumsy; now FTL[1] is the data for codim 2

 codim:=3;
 print "Now I've set codim to 3. FaceTupleList has " cat IntegerToString(#FaceTupleList) cat " entries at present.";
 print "Representatives has " cat IntegerToString(#Representatives) cat " entries at present.";
 while n^2-codim ge limit do
  print "Now doing it for Codim " cat IntegerToString(codim);
  FaceTuplesInCodim:=[**];
  for i in [1..#perfectlist] do
   FaceTuples:=[**];
   S:=MinimalVectors(perfectlist[i]);
   for j in [1..#FaceTupleList[codim-2][i]] do
    Intersection:=facelist[i][FaceTupleList[codim-2][i][j][1]];
    for l in FaceTupleList[codim-2][i][j] do
     Intersection:=facelist[i][l] meet Intersection;
    end for;
    for k in [1..#facelist[i]] do
     IntersectionTemp:=facelist[i][k] meet Intersection;
     if #IntersectionTemp gt 1 then
      if #FindPerpListList([S[l] : l in IntersectionTemp]) eq codim then
       L:=FaceTupleList[codim-2][i][j];
       Append(~L,k);
       Append(~FaceTuples, L  );
      end if;
     end if;
    end for;
   end for;
   Append(~FaceTuplesInCodim,FaceTuples);
  end for;
  Append(~FaceTupleList,FaceTuplesInCodim);
  codim:=codim+1;
 end while; 
 print "Tuples done. FaceTupleList has " cat IntegerToString(#FaceTupleList) cat " entries.";
 //Compute corank 1 classes:
 print "Starting the computation of codim 1 classes.";
 TempList:=[**];
 for i in [1..#perfectlist] do
  for j in [1..#CriticalValueList[i]] do
   Append(~TempList , perfectlist[i]+(CriticalValueList[i][j]/2)*facevectList[i][j][1] );
  end for;
 end for;

 print "TempList done. Starting equivalence testing for codim 1.";

 MinClassReps:=[TempList[1]];
 for x in TempList do
  isi:=false;
  for y in MinClassReps do
   if AreEquivalentMinimalClasses(x,y) then
    isi:=true;
   end if;
  end for;
  if not isi then
   Append(~MinClassReps,x);
  end if;
 end for;

 Append(~Representatives,MinClassReps);
 print "Corank 1 done.";
 //Compute classes of corank >= 2

 codim:=2;

 print "Starting codim" cat IntegerToString(codim) cat " computations.";

 while n^2-codim ge limit do
  TempList:=[**];
  for i in [1..#perfectlist] do
   for j in [1..#FaceTupleList[codim-1][i]] do
    T:=MatrixRing(K,n)!perfectlist[i];
    for k in FaceTupleList[codim-1][i][j] do
     T:=T+(CriticalValueList[i][k]/(2*codim))*facevectList[i][k][1];
    end for;
    if not IsPositiveDefinite(TraceForm(T)) then print "Error, not pos.def.";end if;
    if pcorank(T) ne codim then print "Wrong pcorank at " cat IntegerToString(j); break i; codim:=n^3; end if;
    Append(~TempList,T);
   end for;
  end for;

  print "TempList for Codim " cat IntegerToString(codim) cat " done. It has " cat IntegerToString(#TempList) cat " entries. Starting equivalence testing.";

  MinClassReps:=[TempList[1]];
  counter:=1;
  for x in TempList do
   counter+:=1;
   isi:=false;
   for y in MinClassReps do
    if AreEquivalentMinimalClasses(x,y) then
     isi:=true;
    end if;
   end for;
   if not isi then
    Append(~MinClassReps,x);
   end if;
   if counter mod Floor(#TempList/5) eq 0 then
    print "Ca. #TempList/5 forms checked. Please remain patient.";
   end if;
  end for;

  Append(~Representatives,MinClassReps);
  print "Codim " cat IntegerToString(codim) cat " done.";
  codim:=codim+1;
 end while;
end if;

print "Data assembled.";
return Representatives;
end intrinsic;
