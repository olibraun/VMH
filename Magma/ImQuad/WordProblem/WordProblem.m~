import "../../BasicDataImQuad.m": n,d,steinitz;
import "../../InitializeImQuad.m": K,w,tau,p1,p2,ZB,B,BasHermNorm,mmax,F,sqrtd,Injec;
import "../../QHullDirectory.m": qhulldirectory;
import "../Functions/Groups.m": matbas,matbas2,matbas3;

DimSym:=n^2;
ERank:=DimSym-2;
FRank:=DimSym-1;

function MatrixToCoordinates(A)
 coords:=[];
 for i in [1..n] do
  Append(~coords,Rationals()!A[i][i]);
  for j in [i+1..n] do
   coords cat:= Eltseq(A[i][j]);
  end for;
 end for;
 return coords;
end function;
 

intrinsic ComputeEdgesImQuad(V::VData)
 {Compute and save the attribute Edges in V.}
 Edges:=[* *];
 FL:=V`FacesList;
 for i in [1..#FL] do
  edges:={* *};
  F:=FL[i];
  S:=MinimalVectors(V`PerfectList[i]); 
  //S:=[HermitianTranspose(x)*x: x in MinimalVectors(V`PerfectList[i])];
  for j in [1..#F] do
   for k in [j+1..#F] do
    s:=F[j] meet F[k];
    if s ne {} then
     s:=Setseq(F[j] meet F[k]);
     //print s;
     d:=PerfectionRankList([S[l] : l in s]);
     if d eq ERank then
      Include(~edges,s);
     end if;
    end if;
   end for;
  end for;
  Append(~Edges,edges);
 end for;
 V`Edges:=Edges;
end intrinsic;

intrinsic ComputeBarycentersImQuad(V::VData)
 {Compute and save the attribute Barycenters in V.}
 Barycenters:=[* *];
 PL:=V`PerfectList;
 for P in PL do
  S:=MinimalVectors(P);
  B:=(1/#S)*(&+[HermitianTranspose(x)*x/Trace(HermitianTranspose(x)*x) : x in S]);
  Append(~Barycenters,B);
 end for;
 V`Barycenters:=Barycenters;
end intrinsic;

intrinsic ComputeStabilizersImQuad(V::VData)
 {Compute and save the attribute Stabilizers in V.}
 PL:=V`PerfectList;
 V`Stabilizers:=[* ConvertGroupToNumberField(HermitianAutomorphismGroup(P)) : P in PL *];
end intrinsic;

intrinsic GeodesicIntersectionImQuad(M1::Mtrx,M2::Mtrx,Face::Any : printsolution:=false) -> BoolElt
 {Checks if the geodesic from M1 to M2 intersects the face "Face".}
 Q:=Rationals();
 M1:=M1/Trace(M1);
 M2:=M2/Trace(M2);
 Face:=[x/Trace(x) : x in Face];
 Translations:=[Face[i]-Face[1] : i in [2..#Face]];
 A:=KMatrixSpace(Rationals(),#Face,n^2) ! 0;
 for i in [1..#Translations] do
  a:=[];
  for k in [1..n] do
   Append(~a,Rationals()!Translations[i][k][k]);
   for l in [k+1..n] do
    a cat:= Eltseq(Translations[i][k][l]);
   end for;
  end for;
  for j in [1..#a] do
   A[i][j]:=a[j];
  end for;
 end for;
 //print M1-M2;
 a:=[];
 for i in [1..n] do
  Append(~a,Rationals()!( (M1-M2)[i][i] ) );
  for j in [i+1..n] do
   a cat:=Eltseq((M1-M2)[i][j]);
  end for;
 end for;
 for i in [1..#a] do
  A[#Face][i]:=a[i];
 end for;
 LS:=[];
 for i in [1..n] do
  Append(~LS,Rationals()!( (M1-Face[1])[i][i] ) );
  for j in [i+1..n] do
   LS cat:=Eltseq((M1-Face[1])[i][j]);
  end for;
 end for;
 LS:=Vector(LS);
 a,b,c:=IsConsistent(A,LS);
 //return a,b,c;
 if not a then 
  return false,false;
 end if;
 //return b,b[1],b[2],b[3],b[4];
 t:=b[#Face];
 if not (0 lt t and t lt 1) then
  return false,false;
 end if;
 GeneratorsOfPolytope:=[];
 for f in Face do
  coords:=[];
  for i in [1..n] do
   Append(~coords,Rationals()!f[i][i]);
   for j in [i+1..n] do
    coords cat:= Eltseq(f[i][j]);
   end for;
  end for;
  Append(~GeneratorsOfPolytope,coords);
 end for;
 P:=Polytope(GeneratorsOfPolytope);
 solution:=M1+t*(M2-M1);
 coords:=[];
 for i in [1..n] do
  Append(~coords,Q!solution[i][i]);
  for j in [i+1..n] do
   coords cat:= Eltseq(solution[i][j]);
  end for;
 end for;
 Q:=Polytope([coords]);
 /*if not &and [0 le b[i] and b[i] le 1 : i in [1..NumberOfColumns(b)]] then
  return false;
 end if;*/
 if printsolution then
  result:=MatrixRing(K,n)!0;
  k:=0;
  for i in [1..n] do
   result[i][i]:=coords[1+k]; k+:=1;
   for j in [i+1..n] do
    result[i][j]:=coords[k+1]+w*coords[k+2]; k+:=2;
    result[j][i]:=ComplexConjugate(result[i][j]);
   end for;
  end for;
  return Q subset P, result;
 end if;
 return Q subset P , false;
 //return true;
end intrinsic;

intrinsic GeodesicIntersectionImQuad2(M1::Mtrx,M2::Mtrx,Face::Any : printsolution:=false) -> BoolElt
 {Checks if the geodesic from M1 to M2 intersects the face "Face".}
 Q:=Rationals();
 M1:=M1/Trace(M1);
 M2:=M2/Trace(M2);
 Face:=[x/Trace(x) : x in Face];
 Translations:=[Face[i]-Face[1] : i in [2..#Face]];
 A:=KMatrixSpace(Rationals(),#Face,n^2) ! 0;
 for i in [1..#Translations] do
  a:=[];
  for k in [1..n] do
   Append(~a,Rationals()!Translations[i][k][k]);
   for l in [k+1..n] do
    a cat:= Eltseq(Translations[i][k][l]);
   end for;
  end for;
  for j in [1..#a] do
   A[i][j]:=a[j];
  end for;
 end for;
 //print M1-M2;
 a:=[];
 for i in [1..n] do
  Append(~a,Rationals()!( (M1-M2)[i][i] ) );
  for j in [i+1..n] do
   a cat:=Eltseq((M1-M2)[i][j]);
  end for;
 end for;
 for i in [1..#a] do
  A[#Face][i]:=a[i];
 end for;
 LS:=[];
 for i in [1..n] do
  Append(~LS,Rationals()!( (M1-Face[1])[i][i] ) );
  for j in [i+1..n] do
   LS cat:=Eltseq((M1-Face[1])[i][j]);
  end for;
 end for;
 LS:=Vector(LS);
 a,b,c:=IsConsistent(A,LS);
 //return a,b,c;
 if not a then 
  return false,false;
 end if;
 //return b,b[1],b[2],b[3],b[4];
 t:=b[#Face];
 if not (0 le t and t le 1) then
  return false,false;
 end if;
 GeneratorsOfPolytope:=[];
 for f in Face do
  coords:=[];
  for i in [1..n] do
   Append(~coords,Rationals()!f[i][i]);
   for j in [i+1..n] do
    coords cat:= Eltseq(f[i][j]);
   end for;
  end for;
  Append(~GeneratorsOfPolytope,coords);
 end for;
 P:=Polytope(GeneratorsOfPolytope);
 solution:=M1+t*(M2-M1);
 coords:=[];
 for i in [1..n] do
  Append(~coords,Q!solution[i][i]);
  for j in [i+1..n] do
   coords cat:= Eltseq(solution[i][j]);
  end for;
 end for;
 Q:=Polytope([coords]);
 /*if not &and [0 le b[i] and b[i] le 1 : i in [1..NumberOfColumns(b)]] then
  return false;
 end if;*/
 if printsolution then
  result:=MatrixRing(K,n)!0;
  k:=0;
  for i in [1..n] do
   result[i][i]:=coords[1+k]; k+:=1;
   for j in [i+1..n] do
    result[i][j]:=coords[k+1]+w*coords[k+2]; k+:=2;
    result[j][i]:=ComplexConjugate(result[i][j]);
   end for;
  end for;
  return Q subset P, result;
 end if;
 return Q subset P , false;
 //return true;
end intrinsic;

intrinsic ConstructWordImQuad(x::Mtrx,V::VData) -> SeqEnum
 {Solve the word problem for x in GL(L) using the Voronoi data V.}
 if not assigned V`Stabilizers then ComputeStabilizersImQuad(V); end if;
 if not assigned V`Barycenters then ComputeBarycentersImQuad(V); end if;
 Barycenters:=V`Barycenters;
 Stabs:=&cat[  [g : g in G] : G in V`Stabilizers];
 //Stabs:=[MatrixRing(K,n)!1,MatrixRing(K,n)!(-1)];
 //print #Stabs;
 //return Stabs;
 PL:=V`PerfectList;
 FL:=V`FacesList;
 FTL:=V`FaceTrafoList;
 NL:=V`NeighbourList;
 OKGens:=V`OKGens;
 B1:=Barycenters[1];
 B:=B1;
 B2:=HermitianTranspose(x)*B1*x;
 Currents:=[1];
 //print B1 eq B2;
 cur:=1; //current index
 Word:=[];
 found:=true;
 //print (not (x in Stabs)); print found;
 while (not (x in Stabs)) and found do
  //print "Bin in der While-Schleife.";
  //print B1,B2;
  found:=false;
  for j in [1..#FL[cur]] do
   S:=MinimalVectors(PL[cur]);
   FF:=[HermitianTranspose(S[i])*S[i] : i in FL[cur][j]];
   if GeodesicIntersectionImQuad(B1,B2,FF) then
    found:=true; //print "Found";
    g:=FTL[cur][j];
    cur:=NL[cur][j]; Append(~Currents,cur);
    x:=x*g^-1; 
    //x:=g^-1*x;
    if g ne MatrixRing(K,n)!1 then  //KLappt das mit "ne 1"?
     p:=0; e:=0;
     if g in OKGens then p:=Position(OKGens,g); e:=1; end if;
     if -g in OKGens then p:=Position(OKGens,-g); e:=1; end if;
     if g^-1 in OKGens then p:=Position(OKGens,g^-1); e:=-1; end if;
     if -g^-1 in OKGens then p:=Position(OKGens,-g^-1); e:=-1; end if;
     if [p,e] eq [0,0] then return cur,j; end if;
     Append(~Word,[p,e]);
    end if;
    //print cur;
    B1:=Barycenters[cur];
    B2:=HermitianTranspose(x)*B*x;
    //print g,B1;
    break;
   end if;
  end for;
 end while;
 Append(~Word,[0,Position(Stabs,x)]);
 return found,Word,x,Currents,B;
end intrinsic;

intrinsic ConstructWordImQuad2(x::Mtrx,V::VData) -> SeqEnum
 {Alternative: Solve the word problem for x in GL(L) using the Voronoi data V.}
 if not assigned V`Stabilizers then ComputeStabilizersImQuad(V); end if;
 if not assigned V`Barycenters then ComputeBarycentersImQuad(V); end if;
 if not assigned V`Edges then ComputeEdgesImQuad(V); end if;
 Edges:=V`Edges;
 Barycenters:=V`Barycenters;
 Stabs:=&cat[  [g : g in G] : G in V`Stabilizers];
 //Stabs:=[MatrixRing(K,n)!1,MatrixRing(K,n)!(-1)];
 //print #Stabs;
 //return Stabs;
 PL:=V`PerfectList;
 FL:=V`FacesList;
 FTL:=V`FaceTrafoList;
 NL:=V`NeighbourList;
 OKGens:=V`OKGens;
 Currents:=[1];
 xoriginal:=x;
 B1:=Barycenters[1];
 B:=B1;
 B2:=HermitianTranspose(x)*B1*x;
 //print B1 eq B2;
 cur:=1; //current index
 S:=MinimalVectors(PL[1]);
 Word:=[];
 found:=true;
 //print (not (x in Stabs)); print found;
 //while (not (x in Stabs)) and found do
 while not x in Stabs do
  //print found;
  if not found then
   print "I go through edge.";
   //print "!";
   for indices in Edges[cur] do
    //print [HermitianTranspose(S[i])*S[i] : i in indices];
    if GeodesicIntersectionImQuad2(B1,B2,[HermitianTranspose(S[i])*S[i] : i in indices]) then
     Word:=[]; cur:=1; x:=xoriginal;
     B1:=Barycenters[1];
     B2:=HermitianTranspose(x)*Barycenters[1]*x;
     //B1:=Barycenters[cur];
     changed:=false;
     M:=MinimalVectors(PL[1]);
     MM:=[HermitianTranspose(x)*x/Trace(HermitianTranspose(x)*x) : x in M];
     while not changed do
      //B1[1][1]+:=1/Random(1000,2000); B1/:=Trace(B1); print Barycenters[1]-B1;
      for i in [1..n] do
       B1[i][i]+:=1/Random(1000,2000);
       for j in [i+1..n] do
        r1:=1/Random(1000,2000); r2:=1/Random(1000,2000);
        B1[i][j]+:=r1+w*r2; B1[j][i]+:=r1-w*r2;
       end for;
      end for;
      B1/:=Trace(B1);
      Q:=Polytope([ MatrixToCoordinates(B1) ]);
      P:=Polytope([ MatrixToCoordinates(x) : x in MM ]);
      if Q subset P then
       changed:=true;
      end if;
      //B:=B1;
      //B:=Barycenters[1];
     end while;
     break indices;
    end if;
   end for;
  end if;
  found:=false;
  S:=MinimalVectors(PL[cur]);
  for j in [1..#FL[cur]] do
   //S:=MinimalVectors(PL[cur]);
   FF:=[HermitianTranspose(S[i])*S[i] : i in FL[cur][j]];
   b,r:=GeodesicIntersectionImQuad(B1,B2,FF:printsolution:=true);
   if b then
    found:=true; //print "Found";
    g:=FTL[cur][j];
    cur:=NL[cur][j]; Append(~Currents,cur);
    x:=x*g^-1; 
    //x:=g^-1*x;
    if g ne MatrixRing(K,n)!1 then  //KLappt das mit "ne 1"?
     p:=0; e:=0;
     if g in OKGens then p:=Position(OKGens,g); e:=1; end if;
     if -g in OKGens then p:=Position(OKGens,-g); e:=1; end if;
     if g^-1 in OKGens then p:=Position(OKGens,g^-1); e:=-1; end if;
     if -g^-1 in OKGens then p:=Position(OKGens,-g^-1); e:=-1; end if;
     if [p,e] eq [0,0] then return cur,j; end if;
     Append(~Word,[p,e]);
    end if;
    //print cur;
    //B1:=Barycenters[cur];
    B1:=HermitianTranspose(g^-1)*r*g^-1;
    B2:=HermitianTranspose(x)*B*x;
    //print g,B1;
    break;
   end if;
  end for;
 end while;
 Append(~Word,[0,Position(Stabs,x)]);
 return found,Word,x,Currents;
end intrinsic;
