import "Functions.m":FormREPS,ZGENS;

intrinsic ComputeComplexGL(File::MonStgElt)
 {This function will assemble all available information about the well-rounded retract and write it to a file (in GAP-readable format)} 
 //a,b,c,d,ZGENS,e:=VoronoiAlgorithm();
 //FormREPS:=MinimalClasses(a,b,c,d);
 print "Computing Well-Rounded-Complex for full GL";
 print "Now computing stabilizers";
 Stabs:=AssembleStabilizers(FormREPS,true,IsInGL);
 Evenstabs:=AssembleEvenStabilizers(FormREPS,true,IsInGL);
 print "Now computing boundaries";
 BC:=AssembleBoundaryComponents(FormREPS,IsInGL);
 print "Now computing remaining data";
 Dims:=AssembleDimensions(FormREPS);
 Elts:=AssembleElements(BC,Stabs);
 print "Data computed";
 str:="";
 str cat:= DimensionsToGapString(Dims);
 str cat:= ElementsToGapString(Elts);
 str cat:= StabilizersToGapString(Stabs,false);
 str cat:= StabilizersToGapString(Evenstabs,true);
 str cat:= BoundaryComponentsToGapString(BC,Elts);
 str cat:= GeneratorsToGapString(ZGENS);
 Write(File,str);
end intrinsic;	


intrinsic ComputeComplexLowIndexSubgroup(File::MonStgElt,Reps::Any,CheckMembership::Any)
 {...}
 print "Computing Well-Rounded-Complex for subgroup of low index in GL";
 print "Now computing representatives of minimal classes modulo subgroup action";
 index:=#Reps;
 Forms:=[[]:i in [1..#FormREPS]];
 for i in [1..#FormREPS] do
  for j in [1..#FormREPS[i]] do
   S:=StabilizerOfMinClass(FormREPS[i][j]);
   LS:=LowIndexStabilizer(FormREPS[i][j],CheckMembership);
   r:=Order(S)/Order(LS);
   s:=index/r;
   z:=1;
   list:=[Reps[z]*FormREPS[i][j]*HermitianTranspose(Reps[z])];
   //while #list ne s do
   while z lt index do //TEST
    z:=z+1;
    if {CheckMembership(Reps[y]*s*Reps[z]^(-1)) : y in [1..z-1],s in S} eq {false} then	
     Append(~list,Reps[z]*FormREPS[i][j]*HermitianTranspose(Reps[z]));
    end if;
   end while;
   Forms[i]:=Forms[i] cat list;
  end for;
 end for;
 print "Now computing stabilizers";
 Stabs:=AssembleStabilizers(Forms,false,CheckMembership);
 Evenstabs:=AssembleEvenStabilizers(Forms,false,CheckMembership);
 print "Now computing boundaries";
 BC:=AssembleBoundaryComponents(Forms,CheckMembership);
 print "Now computing remaining data";
 Dims:=AssembleDimensions(Forms);
 Elts:=AssembleElements(BC,Stabs);
 print "Data computed"; 
 str:="";
 str cat:= DimensionsToGapString(Dims);
 str cat:= ElementsToGapString(Elts);
 str cat:= StabilizersToGapString(Stabs,false);
 str cat:= StabilizersToGapString(Evenstabs,true);
 str cat:= BoundaryComponentsToGapString(BC,Elts);
 str cat:= GeneratorsToGapString(ZGENS);
 Write(File,str); 
end intrinsic;

